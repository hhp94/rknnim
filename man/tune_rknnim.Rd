% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_rknnim.R
\name{tune_rknnim}
\alias{tune_rknnim}
\title{Tune Parameters for [rknnim()]/[knn_imp()] Imputation}
\usage{
tune_rknnim(
  obj,
  parameters,
  rep = 1,
  num_na = 100,
  max_iter = 1000,
  rowmax = 0.9,
  colmax = 0.9,
  verbose = TRUE,
  cores = 1,
  .parallel = FALSE
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.}

\item{parameters}{A data frame specifying the parameter combinations to tune. Must include columns
`n.feat`, `k`, `n.overlap` and `method`. Duplicate rows are automatically removed.}

\item{rep}{The number of repetitions for injecting missing values and evaluating parameters.
Default is 1.}

\item{num_na}{The number of missing values used to estimate prediction quality. Must be a positive integer.}

\item{max_iter}{Maximum number of iterations to attempt finding valid NA positions (default: 1000).}

\item{rowmax}{A numeric value between 0 and 1. This is the maximum
allowable proportion of missing values in any single row. If a row
exceeds this threshold, the function will stop with an error.}

\item{colmax}{A numeric value between 0 and 1. This is the threshold for the
proportion of missing values in a column. Columns exceeding this
threshold will be imputed using the column mean instead of k-NN.}

\item{verbose}{Print out progress? Default is TRUE.}

\item{cores}{Number of cores to parallelize calculations of distances over. Note: if .parallel is TRUE and cores = n, then each mirai::daemons() process will spawn n cores.}

\item{.parallel}{Logical indicating whether to use parallel processing for multiple windows. Default is FALSE.}
}
\value{
A tibble containing the tuning results. Each row corresponds to a specific repetition and
  parameter combination, with columns:
  \itemize{
    \item `rep`: The repetition number.
    \item `param_id`: The ID of the parameter combination.
    \item `n.feat`, `k`, `n.overlap`, `method`: The parameter values used.
    \item `result`: A nested tibble with columns `truth` (original values) and `estimate`
      (imputed values) for the injected NAs.
  }
}
\description{
This function tunes the parameters for the [rknnim()]/[knn_imp()] imputation method by injecting missing values
into the dataset multiple times and evaluating the imputation performance for different parameter
combinations. Set \code{n.feat = ncol(obj)} and \code{n.overlap = 0} to tune [knn_imp()]
}
\examples{
\dontrun{
data(khanmiss1)

parameters <- dplyr::tibble(
  n.feat = c(100, 100, 100),
  k = c(5, 10, 10),
  n.overlap = c(10, 10, 10),
  method = "euclidean"
)

set.seed(1234)

results <- tune_rknnim(
  khanmiss1,
  parameters,
  rep = 5
)

# Compute multiple metrics using yardstick
library(yardstick)
met_set <- metric_set(mae, rmse, rsq)
results$metrics <- lapply(
  results$result,
  function(x) {
    met_set(x, truth = truth, estimate = estimate)
  }
)

# Unnest the metrics
tidyr::unnest(dplyr::select(results, -result), cols = "metrics")

# View metrics for the first result
results$metrics[[1]]
}

}
