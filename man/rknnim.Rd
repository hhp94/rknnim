% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rknnim.R
\name{rknnim}
\alias{rknnim}
\title{Rolling KNN Imputation}
\usage{
rknnim(
  obj,
  n.feat,
  n.overlap = 10,
  k = 10,
  rowmax = 0.9,
  colmax = 0.9,
  cores = 1,
  method = c("euclidean", "manhattan", "impute.knn"),
  .progress = FALSE,
  .parallel = FALSE
)
}
\arguments{
\item{obj}{A numeric matrix with \strong{samples in rows} and \strong{features in columns}.}

\item{n.feat}{Integer specifying the number of features (columns) in each window. Must be between 2 and the number of columns in \code{obj}.}

\item{n.overlap}{Integer specifying the overlap between consecutive windows. Default is 10. Must be between 0 and \code{n.feat - 1}.}

\item{k}{An integer specifying the number of nearest neighbors to use for
imputation. Must be between 1 and the number of columns.}

\item{rowmax}{A numeric value between 0 and 1. This is the maximum
allowable proportion of missing values in any single row. If a row
exceeds this threshold, the function will stop with an error.}

\item{colmax}{A numeric value between 0 and 1. This is the threshold for the
proportion of missing values in a column. Columns exceeding this
threshold will be imputed using the column mean instead of k-NN.}

\item{cores}{Number of cores to parallelize calculations of distances over. Note: if .parallel is TRUE and cores = n, then each mirai::daemons() process will spawn n cores.}

\item{method}{A character string specifying the distance metric for k-NN.
Acceptable values are `"euclidean"`, `"manhattan"`, or `"impute.knn"`.
Defaults to `"euclidean"`. See [knn_imp()].}

\item{.progress}{Logical indicating whether to show a progress bar. Default is FALSE.}

\item{.parallel}{Logical indicating whether to use parallel processing for multiple windows. Default is FALSE.}
}
\value{
A numeric matrix of the same dimensions as \code{obj} with missing values imputed.
}
\description{
Performs rolling window KNN imputation on a numeric matrix to handle missing values.
The matrix is divided into overlapping windows, and imputation is applied to each window.
Overlapping regions are averaged to produce the final imputed matrix.
}
\examples{
\dontrun{
data(khanmiss1)
imputed <- rknnim(t(khanmiss1), k = 10, n.feat = 100, n.overlap = 10)
}

}
